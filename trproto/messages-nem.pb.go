// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.28.1
// 	protoc        v3.12.4
// source: messages-nem.proto

package trproto

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// *
// Type of levy which will be used for mosaic
type NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy int32

const (
	NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_MosaicLevy_Absolute   NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy = 1
	NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_MosaicLevy_Percentile NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy = 2
)

// Enum value maps for NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy.
var (
	NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_name = map[int32]string{
		1: "MosaicLevy_Absolute",
		2: "MosaicLevy_Percentile",
	}
	NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy_value = map[string]int32{
		"MosaicLevy_Absolute":   1,
		"MosaicLevy_Percentile": 2,
	}
)

func (x NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy) Enum() *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy {
	p := new(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy)
	*p = x
	return p
}

func (x NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy) Descriptor() protoreflect.EnumDescriptor {
	return file_messages_nem_proto_enumTypes[0].Descriptor()
}

func (NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy) Type() protoreflect.EnumType {
	return &file_messages_nem_proto_enumTypes[0]
}

func (x NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy(num)
	return nil
}

// Deprecated: Use NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy.Descriptor instead.
func (NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy) EnumDescriptor() ([]byte, []int) {
	return file_messages_nem_proto_rawDescGZIP(), []int{2, 3, 0, 0}
}

// *
// Type of supply change which will be applied to mosaic
type NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType int32

const (
	NEMSignTx_NEMMosaicSupplyChange_SupplyChange_Increase NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType = 1
	NEMSignTx_NEMMosaicSupplyChange_SupplyChange_Decrease NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType = 2
)

// Enum value maps for NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType.
var (
	NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_name = map[int32]string{
		1: "SupplyChange_Increase",
		2: "SupplyChange_Decrease",
	}
	NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType_value = map[string]int32{
		"SupplyChange_Increase": 1,
		"SupplyChange_Decrease": 2,
	}
)

func (x NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType) Enum() *NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType {
	p := new(NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType)
	*p = x
	return p
}

func (x NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType) Descriptor() protoreflect.EnumDescriptor {
	return file_messages_nem_proto_enumTypes[1].Descriptor()
}

func (NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType) Type() protoreflect.EnumType {
	return &file_messages_nem_proto_enumTypes[1]
}

func (x NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType(num)
	return nil
}

// Deprecated: Use NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType.Descriptor instead.
func (NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType) EnumDescriptor() ([]byte, []int) {
	return file_messages_nem_proto_rawDescGZIP(), []int{2, 4, 0}
}

// *
// Type of cosignatory modification
type NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType int32

const (
	NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_CosignatoryModification_Add    NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType = 1
	NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_CosignatoryModification_Delete NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType = 2
)

// Enum value maps for NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType.
var (
	NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_name = map[int32]string{
		1: "CosignatoryModification_Add",
		2: "CosignatoryModification_Delete",
	}
	NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType_value = map[string]int32{
		"CosignatoryModification_Add":    1,
		"CosignatoryModification_Delete": 2,
	}
)

func (x NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType) Enum() *NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType {
	p := new(NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType)
	*p = x
	return p
}

func (x NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType) Descriptor() protoreflect.EnumDescriptor {
	return file_messages_nem_proto_enumTypes[2].Descriptor()
}

func (NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType) Type() protoreflect.EnumType {
	return &file_messages_nem_proto_enumTypes[2]
}

func (x NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType(num)
	return nil
}

// Deprecated: Use NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType.Descriptor instead.
func (NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType) EnumDescriptor() ([]byte, []int) {
	return file_messages_nem_proto_rawDescGZIP(), []int{2, 5, 0, 0}
}

// *
// Mode of importance transfer
type NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode int32

const (
	NEMSignTx_NEMImportanceTransfer_ImportanceTransfer_Activate   NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode = 1
	NEMSignTx_NEMImportanceTransfer_ImportanceTransfer_Deactivate NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode = 2
)

// Enum value maps for NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode.
var (
	NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_name = map[int32]string{
		1: "ImportanceTransfer_Activate",
		2: "ImportanceTransfer_Deactivate",
	}
	NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode_value = map[string]int32{
		"ImportanceTransfer_Activate":   1,
		"ImportanceTransfer_Deactivate": 2,
	}
)

func (x NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode) Enum() *NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode {
	p := new(NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode)
	*p = x
	return p
}

func (x NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode) Descriptor() protoreflect.EnumDescriptor {
	return file_messages_nem_proto_enumTypes[3].Descriptor()
}

func (NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode) Type() protoreflect.EnumType {
	return &file_messages_nem_proto_enumTypes[3]
}

func (x NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Do not use.
func (x *NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode) UnmarshalJSON(b []byte) error {
	num, err := protoimpl.X.UnmarshalJSONEnum(x.Descriptor(), b)
	if err != nil {
		return err
	}
	*x = NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode(num)
	return nil
}

// Deprecated: Use NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode.Descriptor instead.
func (NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode) EnumDescriptor() ([]byte, []int) {
	return file_messages_nem_proto_rawDescGZIP(), []int{2, 6, 0}
}

// *
// Request: Ask device for NEM address corresponding to address_n path
// @start
// @next NEMAddress
// @next Failure
type NEMGetAddress struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	AddressN    []uint32 `protobuf:"varint,1,rep,name=address_n,json=addressN" json:"address_n,omitempty"`          // BIP-32 path to derive the key from master node
	Network     *uint32  `protobuf:"varint,2,opt,name=network,def=104" json:"network,omitempty"`                    // Network ID (0x68 = Mainnet, 0x98 = Testnet, 0x60 = Mijin)
	ShowDisplay *bool    `protobuf:"varint,3,opt,name=show_display,json=showDisplay" json:"show_display,omitempty"` // Optionally show on display before sending the result
}

// Default values for NEMGetAddress fields.
const (
	Default_NEMGetAddress_Network = uint32(104)
)

func (x *NEMGetAddress) Reset() {
	*x = NEMGetAddress{}
	if protoimpl.UnsafeEnabled {
		mi := &file_messages_nem_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NEMGetAddress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NEMGetAddress) ProtoMessage() {}

func (x *NEMGetAddress) ProtoReflect() protoreflect.Message {
	mi := &file_messages_nem_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NEMGetAddress.ProtoReflect.Descriptor instead.
func (*NEMGetAddress) Descriptor() ([]byte, []int) {
	return file_messages_nem_proto_rawDescGZIP(), []int{0}
}

func (x *NEMGetAddress) GetAddressN() []uint32 {
	if x != nil {
		return x.AddressN
	}
	return nil
}

func (x *NEMGetAddress) GetNetwork() uint32 {
	if x != nil && x.Network != nil {
		return *x.Network
	}
	return Default_NEMGetAddress_Network
}

func (x *NEMGetAddress) GetShowDisplay() bool {
	if x != nil && x.ShowDisplay != nil {
		return *x.ShowDisplay
	}
	return false
}

// *
// Response: Contains NEM address derived from device private seed
// @end
type NEMAddress struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Address *string `protobuf:"bytes,1,req,name=address" json:"address,omitempty"` // NEM address in Base32 encoding
}

func (x *NEMAddress) Reset() {
	*x = NEMAddress{}
	if protoimpl.UnsafeEnabled {
		mi := &file_messages_nem_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NEMAddress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NEMAddress) ProtoMessage() {}

func (x *NEMAddress) ProtoReflect() protoreflect.Message {
	mi := &file_messages_nem_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NEMAddress.ProtoReflect.Descriptor instead.
func (*NEMAddress) Descriptor() ([]byte, []int) {
	return file_messages_nem_proto_rawDescGZIP(), []int{1}
}

func (x *NEMAddress) GetAddress() string {
	if x != nil && x.Address != nil {
		return *x.Address
	}
	return ""
}

// *
// Request: Ask device to sign transaction
// @start
// @next NEMSignedTx
// @next Failure
type NEMSignTx struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Transaction           *NEMSignTx_NEMTransactionCommon     `protobuf:"bytes,1,req,name=transaction" json:"transaction,omitempty"`                                                  // Common part of transaction
	Multisig              *NEMSignTx_NEMTransactionCommon     `protobuf:"bytes,2,opt,name=multisig" json:"multisig,omitempty"`                                                        // Common part of inner transaction for multisig transactions
	Transfer              *NEMSignTx_NEMTransfer              `protobuf:"bytes,3,opt,name=transfer" json:"transfer,omitempty"`                                                        // Transfer transaction part
	Cosigning             *bool                               `protobuf:"varint,4,opt,name=cosigning" json:"cosigning,omitempty"`                                                     // Whether cosigning or initiating the multisig transaction
	ProvisionNamespace    *NEMSignTx_NEMProvisionNamespace    `protobuf:"bytes,5,opt,name=provision_namespace,json=provisionNamespace" json:"provision_namespace,omitempty"`          // Provision namespace part
	MosaicCreation        *NEMSignTx_NEMMosaicCreation        `protobuf:"bytes,6,opt,name=mosaic_creation,json=mosaicCreation" json:"mosaic_creation,omitempty"`                      // Mosaic definition creation part
	SupplyChange          *NEMSignTx_NEMMosaicSupplyChange    `protobuf:"bytes,7,opt,name=supply_change,json=supplyChange" json:"supply_change,omitempty"`                            // Mosaic supply change part
	AggregateModification *NEMSignTx_NEMAggregateModification `protobuf:"bytes,8,opt,name=aggregate_modification,json=aggregateModification" json:"aggregate_modification,omitempty"` // Aggregate modification part
	ImportanceTransfer    *NEMSignTx_NEMImportanceTransfer    `protobuf:"bytes,9,opt,name=importance_transfer,json=importanceTransfer" json:"importance_transfer,omitempty"`          // Importance transfer part
}

func (x *NEMSignTx) Reset() {
	*x = NEMSignTx{}
	if protoimpl.UnsafeEnabled {
		mi := &file_messages_nem_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NEMSignTx) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NEMSignTx) ProtoMessage() {}

func (x *NEMSignTx) ProtoReflect() protoreflect.Message {
	mi := &file_messages_nem_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NEMSignTx.ProtoReflect.Descriptor instead.
func (*NEMSignTx) Descriptor() ([]byte, []int) {
	return file_messages_nem_proto_rawDescGZIP(), []int{2}
}

func (x *NEMSignTx) GetTransaction() *NEMSignTx_NEMTransactionCommon {
	if x != nil {
		return x.Transaction
	}
	return nil
}

func (x *NEMSignTx) GetMultisig() *NEMSignTx_NEMTransactionCommon {
	if x != nil {
		return x.Multisig
	}
	return nil
}

func (x *NEMSignTx) GetTransfer() *NEMSignTx_NEMTransfer {
	if x != nil {
		return x.Transfer
	}
	return nil
}

func (x *NEMSignTx) GetCosigning() bool {
	if x != nil && x.Cosigning != nil {
		return *x.Cosigning
	}
	return false
}

func (x *NEMSignTx) GetProvisionNamespace() *NEMSignTx_NEMProvisionNamespace {
	if x != nil {
		return x.ProvisionNamespace
	}
	return nil
}

func (x *NEMSignTx) GetMosaicCreation() *NEMSignTx_NEMMosaicCreation {
	if x != nil {
		return x.MosaicCreation
	}
	return nil
}

func (x *NEMSignTx) GetSupplyChange() *NEMSignTx_NEMMosaicSupplyChange {
	if x != nil {
		return x.SupplyChange
	}
	return nil
}

func (x *NEMSignTx) GetAggregateModification() *NEMSignTx_NEMAggregateModification {
	if x != nil {
		return x.AggregateModification
	}
	return nil
}

func (x *NEMSignTx) GetImportanceTransfer() *NEMSignTx_NEMImportanceTransfer {
	if x != nil {
		return x.ImportanceTransfer
	}
	return nil
}

// *
// Response: Contains NEM transaction data and signature
// @end
type NEMSignedTx struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Data      []byte `protobuf:"bytes,1,req,name=data" json:"data,omitempty"`           // Transaction data
	Signature []byte `protobuf:"bytes,2,req,name=signature" json:"signature,omitempty"` // Signature for the transaction
}

func (x *NEMSignedTx) Reset() {
	*x = NEMSignedTx{}
	if protoimpl.UnsafeEnabled {
		mi := &file_messages_nem_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NEMSignedTx) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NEMSignedTx) ProtoMessage() {}

func (x *NEMSignedTx) ProtoReflect() protoreflect.Message {
	mi := &file_messages_nem_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NEMSignedTx.ProtoReflect.Descriptor instead.
func (*NEMSignedTx) Descriptor() ([]byte, []int) {
	return file_messages_nem_proto_rawDescGZIP(), []int{3}
}

func (x *NEMSignedTx) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *NEMSignedTx) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

// *
// Request: Ask device to decrypt NEM transaction payload
// @start
// @next NEMDecryptedMessage
// @next Failure
type NEMDecryptMessage struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	AddressN  []uint32 `protobuf:"varint,1,rep,name=address_n,json=addressN" json:"address_n,omitempty"`   // BIP-32 path to derive the key from master node
	Network   *uint32  `protobuf:"varint,2,opt,name=network" json:"network,omitempty"`                     // Network ID (0x68 = Mainnet, 0x98 = Testnet, 0x60 = Mijin)
	PublicKey []byte   `protobuf:"bytes,3,opt,name=public_key,json=publicKey" json:"public_key,omitempty"` // Public key of the other party
	Payload   []byte   `protobuf:"bytes,4,opt,name=payload" json:"payload,omitempty"`                      // Actual message data (encrypted)
}

func (x *NEMDecryptMessage) Reset() {
	*x = NEMDecryptMessage{}
	if protoimpl.UnsafeEnabled {
		mi := &file_messages_nem_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NEMDecryptMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NEMDecryptMessage) ProtoMessage() {}

func (x *NEMDecryptMessage) ProtoReflect() protoreflect.Message {
	mi := &file_messages_nem_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NEMDecryptMessage.ProtoReflect.Descriptor instead.
func (*NEMDecryptMessage) Descriptor() ([]byte, []int) {
	return file_messages_nem_proto_rawDescGZIP(), []int{4}
}

func (x *NEMDecryptMessage) GetAddressN() []uint32 {
	if x != nil {
		return x.AddressN
	}
	return nil
}

func (x *NEMDecryptMessage) GetNetwork() uint32 {
	if x != nil && x.Network != nil {
		return *x.Network
	}
	return 0
}

func (x *NEMDecryptMessage) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *NEMDecryptMessage) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

// *
// Response: Contains decrypted NEM transaction payload
// @end
type NEMDecryptedMessage struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Payload []byte `protobuf:"bytes,1,req,name=payload" json:"payload,omitempty"` // Actual message data (unencrypted)
}

func (x *NEMDecryptedMessage) Reset() {
	*x = NEMDecryptedMessage{}
	if protoimpl.UnsafeEnabled {
		mi := &file_messages_nem_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NEMDecryptedMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NEMDecryptedMessage) ProtoMessage() {}

func (x *NEMDecryptedMessage) ProtoReflect() protoreflect.Message {
	mi := &file_messages_nem_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NEMDecryptedMessage.ProtoReflect.Descriptor instead.
func (*NEMDecryptedMessage) Descriptor() ([]byte, []int) {
	return file_messages_nem_proto_rawDescGZIP(), []int{5}
}

func (x *NEMDecryptedMessage) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

// *
// Structure representing the common part for NEM transactions
type NEMSignTx_NEMTransactionCommon struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	AddressN  []uint32 `protobuf:"varint,1,rep,name=address_n,json=addressN" json:"address_n,omitempty"` // BIP-32 path to derive the key from master node
	Network   *uint32  `protobuf:"varint,2,opt,name=network,def=104" json:"network,omitempty"`           // Network ID (0x68 = Mainnet, 0x98 = Testnet, 0x60 = Mijin)
	Timestamp *uint32  `protobuf:"varint,3,req,name=timestamp" json:"timestamp,omitempty"`               // Number of seconds elapsed since the creation of the nemesis block
	Fee       *uint64  `protobuf:"varint,4,req,name=fee" json:"fee,omitempty"`                           // Fee for the transaction
	Deadline  *uint32  `protobuf:"varint,5,req,name=deadline" json:"deadline,omitempty"`                 // Deadline of the transaction
	Signer    []byte   `protobuf:"bytes,6,opt,name=signer" json:"signer,omitempty"`                      // Public key of the account (for multisig transactions)
}

// Default values for NEMSignTx_NEMTransactionCommon fields.
const (
	Default_NEMSignTx_NEMTransactionCommon_Network = uint32(104)
)

func (x *NEMSignTx_NEMTransactionCommon) Reset() {
	*x = NEMSignTx_NEMTransactionCommon{}
	if protoimpl.UnsafeEnabled {
		mi := &file_messages_nem_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NEMSignTx_NEMTransactionCommon) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NEMSignTx_NEMTransactionCommon) ProtoMessage() {}

func (x *NEMSignTx_NEMTransactionCommon) ProtoReflect() protoreflect.Message {
	mi := &file_messages_nem_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NEMSignTx_NEMTransactionCommon.ProtoReflect.Descriptor instead.
func (*NEMSignTx_NEMTransactionCommon) Descriptor() ([]byte, []int) {
	return file_messages_nem_proto_rawDescGZIP(), []int{2, 0}
}

func (x *NEMSignTx_NEMTransactionCommon) GetAddressN() []uint32 {
	if x != nil {
		return x.AddressN
	}
	return nil
}

func (x *NEMSignTx_NEMTransactionCommon) GetNetwork() uint32 {
	if x != nil && x.Network != nil {
		return *x.Network
	}
	return Default_NEMSignTx_NEMTransactionCommon_Network
}

func (x *NEMSignTx_NEMTransactionCommon) GetTimestamp() uint32 {
	if x != nil && x.Timestamp != nil {
		return *x.Timestamp
	}
	return 0
}

func (x *NEMSignTx_NEMTransactionCommon) GetFee() uint64 {
	if x != nil && x.Fee != nil {
		return *x.Fee
	}
	return 0
}

func (x *NEMSignTx_NEMTransactionCommon) GetDeadline() uint32 {
	if x != nil && x.Deadline != nil {
		return *x.Deadline
	}
	return 0
}

func (x *NEMSignTx_NEMTransactionCommon) GetSigner() []byte {
	if x != nil {
		return x.Signer
	}
	return nil
}

// *
// Structure representing the transfer transaction part for NEM transactions
type NEMSignTx_NEMTransfer struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Recipient *string                            `protobuf:"bytes,1,req,name=recipient" json:"recipient,omitempty"`                  // Address of the recipient
	Amount    *uint64                            `protobuf:"varint,2,req,name=amount" json:"amount,omitempty"`                       // Amount of micro NEM that is transferred
	Payload   []byte                             `protobuf:"bytes,3,opt,name=payload" json:"payload,omitempty"`                      // Actual message data (unencrypted)
	PublicKey []byte                             `protobuf:"bytes,4,opt,name=public_key,json=publicKey" json:"public_key,omitempty"` // Public key of the recipient (for encrypted payloads)
	Mosaics   []*NEMSignTx_NEMTransfer_NEMMosaic `protobuf:"bytes,5,rep,name=mosaics" json:"mosaics,omitempty"`                      // Attached mosaics
}

func (x *NEMSignTx_NEMTransfer) Reset() {
	*x = NEMSignTx_NEMTransfer{}
	if protoimpl.UnsafeEnabled {
		mi := &file_messages_nem_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NEMSignTx_NEMTransfer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NEMSignTx_NEMTransfer) ProtoMessage() {}

func (x *NEMSignTx_NEMTransfer) ProtoReflect() protoreflect.Message {
	mi := &file_messages_nem_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NEMSignTx_NEMTransfer.ProtoReflect.Descriptor instead.
func (*NEMSignTx_NEMTransfer) Descriptor() ([]byte, []int) {
	return file_messages_nem_proto_rawDescGZIP(), []int{2, 1}
}

func (x *NEMSignTx_NEMTransfer) GetRecipient() string {
	if x != nil && x.Recipient != nil {
		return *x.Recipient
	}
	return ""
}

func (x *NEMSignTx_NEMTransfer) GetAmount() uint64 {
	if x != nil && x.Amount != nil {
		return *x.Amount
	}
	return 0
}

func (x *NEMSignTx_NEMTransfer) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *NEMSignTx_NEMTransfer) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

func (x *NEMSignTx_NEMTransfer) GetMosaics() []*NEMSignTx_NEMTransfer_NEMMosaic {
	if x != nil {
		return x.Mosaics
	}
	return nil
}

// *
// Structure representing the provision namespace part for NEM transactions
type NEMSignTx_NEMProvisionNamespace struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Namespace *string `protobuf:"bytes,1,req,name=namespace" json:"namespace,omitempty"` // New part concatenated to the parent
	Parent    *string `protobuf:"bytes,2,opt,name=parent" json:"parent,omitempty"`       // Parent namespace (for child namespaces)
	Sink      *string `protobuf:"bytes,3,req,name=sink" json:"sink,omitempty"`           // Rental fee sink address
	Fee       *uint64 `protobuf:"varint,4,req,name=fee" json:"fee,omitempty"`            // Rental fee
}

func (x *NEMSignTx_NEMProvisionNamespace) Reset() {
	*x = NEMSignTx_NEMProvisionNamespace{}
	if protoimpl.UnsafeEnabled {
		mi := &file_messages_nem_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NEMSignTx_NEMProvisionNamespace) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NEMSignTx_NEMProvisionNamespace) ProtoMessage() {}

func (x *NEMSignTx_NEMProvisionNamespace) ProtoReflect() protoreflect.Message {
	mi := &file_messages_nem_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NEMSignTx_NEMProvisionNamespace.ProtoReflect.Descriptor instead.
func (*NEMSignTx_NEMProvisionNamespace) Descriptor() ([]byte, []int) {
	return file_messages_nem_proto_rawDescGZIP(), []int{2, 2}
}

func (x *NEMSignTx_NEMProvisionNamespace) GetNamespace() string {
	if x != nil && x.Namespace != nil {
		return *x.Namespace
	}
	return ""
}

func (x *NEMSignTx_NEMProvisionNamespace) GetParent() string {
	if x != nil && x.Parent != nil {
		return *x.Parent
	}
	return ""
}

func (x *NEMSignTx_NEMProvisionNamespace) GetSink() string {
	if x != nil && x.Sink != nil {
		return *x.Sink
	}
	return ""
}

func (x *NEMSignTx_NEMProvisionNamespace) GetFee() uint64 {
	if x != nil && x.Fee != nil {
		return *x.Fee
	}
	return 0
}

// *
// Structure representing the mosaic definition creation part for NEM transactions
type NEMSignTx_NEMMosaicCreation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Definition *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition `protobuf:"bytes,1,req,name=definition" json:"definition,omitempty"` // Mosaic definition
	Sink       *string                                          `protobuf:"bytes,2,req,name=sink" json:"sink,omitempty"`             // Creation fee sink address
	Fee        *uint64                                          `protobuf:"varint,3,req,name=fee" json:"fee,omitempty"`              // Creation fee
}

func (x *NEMSignTx_NEMMosaicCreation) Reset() {
	*x = NEMSignTx_NEMMosaicCreation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_messages_nem_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NEMSignTx_NEMMosaicCreation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NEMSignTx_NEMMosaicCreation) ProtoMessage() {}

func (x *NEMSignTx_NEMMosaicCreation) ProtoReflect() protoreflect.Message {
	mi := &file_messages_nem_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NEMSignTx_NEMMosaicCreation.ProtoReflect.Descriptor instead.
func (*NEMSignTx_NEMMosaicCreation) Descriptor() ([]byte, []int) {
	return file_messages_nem_proto_rawDescGZIP(), []int{2, 3}
}

func (x *NEMSignTx_NEMMosaicCreation) GetDefinition() *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition {
	if x != nil {
		return x.Definition
	}
	return nil
}

func (x *NEMSignTx_NEMMosaicCreation) GetSink() string {
	if x != nil && x.Sink != nil {
		return *x.Sink
	}
	return ""
}

func (x *NEMSignTx_NEMMosaicCreation) GetFee() uint64 {
	if x != nil && x.Fee != nil {
		return *x.Fee
	}
	return 0
}

// *
// Structure representing the mosaic supply change part for NEM transactions
type NEMSignTx_NEMMosaicSupplyChange struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Namespace *string                                              `protobuf:"bytes,1,req,name=namespace" json:"namespace,omitempty"`                                                                        // Fully qualified name of the namespace
	Mosaic    *string                                              `protobuf:"bytes,2,req,name=mosaic" json:"mosaic,omitempty"`                                                                              // Name of the mosaic definition
	Type      *NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType `protobuf:"varint,3,req,name=type,enum=hw.trezor.messages.nem.NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType" json:"type,omitempty"` // Type of supply change
	Delta     *uint64                                              `protobuf:"varint,4,req,name=delta" json:"delta,omitempty"`                                                                               // Supply delta
}

func (x *NEMSignTx_NEMMosaicSupplyChange) Reset() {
	*x = NEMSignTx_NEMMosaicSupplyChange{}
	if protoimpl.UnsafeEnabled {
		mi := &file_messages_nem_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NEMSignTx_NEMMosaicSupplyChange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NEMSignTx_NEMMosaicSupplyChange) ProtoMessage() {}

func (x *NEMSignTx_NEMMosaicSupplyChange) ProtoReflect() protoreflect.Message {
	mi := &file_messages_nem_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NEMSignTx_NEMMosaicSupplyChange.ProtoReflect.Descriptor instead.
func (*NEMSignTx_NEMMosaicSupplyChange) Descriptor() ([]byte, []int) {
	return file_messages_nem_proto_rawDescGZIP(), []int{2, 4}
}

func (x *NEMSignTx_NEMMosaicSupplyChange) GetNamespace() string {
	if x != nil && x.Namespace != nil {
		return *x.Namespace
	}
	return ""
}

func (x *NEMSignTx_NEMMosaicSupplyChange) GetMosaic() string {
	if x != nil && x.Mosaic != nil {
		return *x.Mosaic
	}
	return ""
}

func (x *NEMSignTx_NEMMosaicSupplyChange) GetType() NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return NEMSignTx_NEMMosaicSupplyChange_SupplyChange_Increase
}

func (x *NEMSignTx_NEMMosaicSupplyChange) GetDelta() uint64 {
	if x != nil && x.Delta != nil {
		return *x.Delta
	}
	return 0
}

// *
// Structure representing the aggregate modification part for NEM transactions
type NEMSignTx_NEMAggregateModification struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Modifications  []*NEMSignTx_NEMAggregateModification_NEMCosignatoryModification `protobuf:"bytes,1,rep,name=modifications" json:"modifications,omitempty"`                            // Cosignatory modifications
	RelativeChange *int32                                                           `protobuf:"zigzag32,2,opt,name=relative_change,json=relativeChange" json:"relative_change,omitempty"` // Relative change of the minimum cosignatories
}

func (x *NEMSignTx_NEMAggregateModification) Reset() {
	*x = NEMSignTx_NEMAggregateModification{}
	if protoimpl.UnsafeEnabled {
		mi := &file_messages_nem_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NEMSignTx_NEMAggregateModification) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NEMSignTx_NEMAggregateModification) ProtoMessage() {}

func (x *NEMSignTx_NEMAggregateModification) ProtoReflect() protoreflect.Message {
	mi := &file_messages_nem_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NEMSignTx_NEMAggregateModification.ProtoReflect.Descriptor instead.
func (*NEMSignTx_NEMAggregateModification) Descriptor() ([]byte, []int) {
	return file_messages_nem_proto_rawDescGZIP(), []int{2, 5}
}

func (x *NEMSignTx_NEMAggregateModification) GetModifications() []*NEMSignTx_NEMAggregateModification_NEMCosignatoryModification {
	if x != nil {
		return x.Modifications
	}
	return nil
}

func (x *NEMSignTx_NEMAggregateModification) GetRelativeChange() int32 {
	if x != nil && x.RelativeChange != nil {
		return *x.RelativeChange
	}
	return 0
}

// *
// Structure representing the importance transfer part for NEM transactions
type NEMSignTx_NEMImportanceTransfer struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Mode      *NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode `protobuf:"varint,1,req,name=mode,enum=hw.trezor.messages.nem.NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode" json:"mode,omitempty"` // Mode of importance transfer
	PublicKey []byte                                                     `protobuf:"bytes,2,req,name=public_key,json=publicKey" json:"public_key,omitempty"`                                                             // Public key of the remote account
}

func (x *NEMSignTx_NEMImportanceTransfer) Reset() {
	*x = NEMSignTx_NEMImportanceTransfer{}
	if protoimpl.UnsafeEnabled {
		mi := &file_messages_nem_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NEMSignTx_NEMImportanceTransfer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NEMSignTx_NEMImportanceTransfer) ProtoMessage() {}

func (x *NEMSignTx_NEMImportanceTransfer) ProtoReflect() protoreflect.Message {
	mi := &file_messages_nem_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NEMSignTx_NEMImportanceTransfer.ProtoReflect.Descriptor instead.
func (*NEMSignTx_NEMImportanceTransfer) Descriptor() ([]byte, []int) {
	return file_messages_nem_proto_rawDescGZIP(), []int{2, 6}
}

func (x *NEMSignTx_NEMImportanceTransfer) GetMode() NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode {
	if x != nil && x.Mode != nil {
		return *x.Mode
	}
	return NEMSignTx_NEMImportanceTransfer_ImportanceTransfer_Activate
}

func (x *NEMSignTx_NEMImportanceTransfer) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

// *
// Structure representing the mosaic attachment for NEM transfer transactions
type NEMSignTx_NEMTransfer_NEMMosaic struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Namespace *string `protobuf:"bytes,1,req,name=namespace" json:"namespace,omitempty"` // Fully qualified name of the namespace
	Mosaic    *string `protobuf:"bytes,2,req,name=mosaic" json:"mosaic,omitempty"`       // Name of the mosaic definition
	Quantity  *uint64 `protobuf:"varint,3,req,name=quantity" json:"quantity,omitempty"`  // Mosaic quantity, always given in smallest units
}

func (x *NEMSignTx_NEMTransfer_NEMMosaic) Reset() {
	*x = NEMSignTx_NEMTransfer_NEMMosaic{}
	if protoimpl.UnsafeEnabled {
		mi := &file_messages_nem_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NEMSignTx_NEMTransfer_NEMMosaic) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NEMSignTx_NEMTransfer_NEMMosaic) ProtoMessage() {}

func (x *NEMSignTx_NEMTransfer_NEMMosaic) ProtoReflect() protoreflect.Message {
	mi := &file_messages_nem_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NEMSignTx_NEMTransfer_NEMMosaic.ProtoReflect.Descriptor instead.
func (*NEMSignTx_NEMTransfer_NEMMosaic) Descriptor() ([]byte, []int) {
	return file_messages_nem_proto_rawDescGZIP(), []int{2, 1, 0}
}

func (x *NEMSignTx_NEMTransfer_NEMMosaic) GetNamespace() string {
	if x != nil && x.Namespace != nil {
		return *x.Namespace
	}
	return ""
}

func (x *NEMSignTx_NEMTransfer_NEMMosaic) GetMosaic() string {
	if x != nil && x.Mosaic != nil {
		return *x.Mosaic
	}
	return ""
}

func (x *NEMSignTx_NEMTransfer_NEMMosaic) GetQuantity() uint64 {
	if x != nil && x.Quantity != nil {
		return *x.Quantity
	}
	return 0
}

// *
// Structure representing a mosaic definition
type NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Name          *string                                                        `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`                                                                                            // User-friendly name of the mosaic (for whitelisted mosaics)
	Ticker        *string                                                        `protobuf:"bytes,2,opt,name=ticker" json:"ticker,omitempty"`                                                                                        // Ticker of the mosaic (for whitelisted mosaics)
	Namespace     *string                                                        `protobuf:"bytes,3,req,name=namespace" json:"namespace,omitempty"`                                                                                  // Fully qualified name of the namespace
	Mosaic        *string                                                        `protobuf:"bytes,4,req,name=mosaic" json:"mosaic,omitempty"`                                                                                        // Name of the mosaic definition
	Divisibility  *uint32                                                        `protobuf:"varint,5,opt,name=divisibility" json:"divisibility,omitempty"`                                                                           // Number of decimal places that a mosaic can be divided into
	Levy          *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy `protobuf:"varint,6,opt,name=levy,enum=hw.trezor.messages.nem.NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy" json:"levy,omitempty"` // Levy type
	Fee           *uint64                                                        `protobuf:"varint,7,opt,name=fee" json:"fee,omitempty"`                                                                                             // Levy fee (interpretation depends on levy type)
	LevyAddress   *string                                                        `protobuf:"bytes,8,opt,name=levy_address,json=levyAddress" json:"levy_address,omitempty"`                                                           // Levy address
	LevyNamespace *string                                                        `protobuf:"bytes,9,opt,name=levy_namespace,json=levyNamespace" json:"levy_namespace,omitempty"`                                                     // Fully qualified name of the namespace of the levy mosaic
	LevyMosaic    *string                                                        `protobuf:"bytes,10,opt,name=levy_mosaic,json=levyMosaic" json:"levy_mosaic,omitempty"`                                                             // Name of the levy mosaic
	Supply        *uint64                                                        `protobuf:"varint,11,opt,name=supply" json:"supply,omitempty"`                                                                                      // Initial supply to create, always given in entire units
	MutableSupply *bool                                                          `protobuf:"varint,12,opt,name=mutable_supply,json=mutableSupply" json:"mutable_supply,omitempty"`                                                   // Mutable supply
	Transferable  *bool                                                          `protobuf:"varint,13,opt,name=transferable" json:"transferable,omitempty"`                                                                          // Mosaic allows transfers among accounts other than the creator
	Description   *string                                                        `protobuf:"bytes,14,req,name=description" json:"description,omitempty"`                                                                             // Mosaic description
	Networks      []uint32                                                       `protobuf:"varint,15,rep,name=networks" json:"networks,omitempty"`                                                                                  // Networks that the mosaic is valid on (for whitelisted mosaics)
}

func (x *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition) Reset() {
	*x = NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition{}
	if protoimpl.UnsafeEnabled {
		mi := &file_messages_nem_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition) ProtoMessage() {}

func (x *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition) ProtoReflect() protoreflect.Message {
	mi := &file_messages_nem_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition.ProtoReflect.Descriptor instead.
func (*NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition) Descriptor() ([]byte, []int) {
	return file_messages_nem_proto_rawDescGZIP(), []int{2, 3, 0}
}

func (x *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition) GetName() string {
	if x != nil && x.Name != nil {
		return *x.Name
	}
	return ""
}

func (x *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition) GetTicker() string {
	if x != nil && x.Ticker != nil {
		return *x.Ticker
	}
	return ""
}

func (x *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition) GetNamespace() string {
	if x != nil && x.Namespace != nil {
		return *x.Namespace
	}
	return ""
}

func (x *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition) GetMosaic() string {
	if x != nil && x.Mosaic != nil {
		return *x.Mosaic
	}
	return ""
}

func (x *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition) GetDivisibility() uint32 {
	if x != nil && x.Divisibility != nil {
		return *x.Divisibility
	}
	return 0
}

func (x *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition) GetLevy() NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy {
	if x != nil && x.Levy != nil {
		return *x.Levy
	}
	return NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_MosaicLevy_Absolute
}

func (x *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition) GetFee() uint64 {
	if x != nil && x.Fee != nil {
		return *x.Fee
	}
	return 0
}

func (x *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition) GetLevyAddress() string {
	if x != nil && x.LevyAddress != nil {
		return *x.LevyAddress
	}
	return ""
}

func (x *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition) GetLevyNamespace() string {
	if x != nil && x.LevyNamespace != nil {
		return *x.LevyNamespace
	}
	return ""
}

func (x *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition) GetLevyMosaic() string {
	if x != nil && x.LevyMosaic != nil {
		return *x.LevyMosaic
	}
	return ""
}

func (x *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition) GetSupply() uint64 {
	if x != nil && x.Supply != nil {
		return *x.Supply
	}
	return 0
}

func (x *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition) GetMutableSupply() bool {
	if x != nil && x.MutableSupply != nil {
		return *x.MutableSupply
	}
	return false
}

func (x *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition) GetTransferable() bool {
	if x != nil && x.Transferable != nil {
		return *x.Transferable
	}
	return false
}

func (x *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition) GetDescription() string {
	if x != nil && x.Description != nil {
		return *x.Description
	}
	return ""
}

func (x *NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition) GetNetworks() []uint32 {
	if x != nil {
		return x.Networks
	}
	return nil
}

// *
// Structure representing the cosignatory modification for aggregate modification transactions
type NEMSignTx_NEMAggregateModification_NEMCosignatoryModification struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Type      *NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType `protobuf:"varint,1,req,name=type,enum=hw.trezor.messages.nem.NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType" json:"type,omitempty"` // Type of cosignatory modification
	PublicKey []byte                                                                             `protobuf:"bytes,2,req,name=public_key,json=publicKey" json:"public_key,omitempty"`                                                                                     // Public key of the cosignatory
}

func (x *NEMSignTx_NEMAggregateModification_NEMCosignatoryModification) Reset() {
	*x = NEMSignTx_NEMAggregateModification_NEMCosignatoryModification{}
	if protoimpl.UnsafeEnabled {
		mi := &file_messages_nem_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NEMSignTx_NEMAggregateModification_NEMCosignatoryModification) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NEMSignTx_NEMAggregateModification_NEMCosignatoryModification) ProtoMessage() {}

func (x *NEMSignTx_NEMAggregateModification_NEMCosignatoryModification) ProtoReflect() protoreflect.Message {
	mi := &file_messages_nem_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NEMSignTx_NEMAggregateModification_NEMCosignatoryModification.ProtoReflect.Descriptor instead.
func (*NEMSignTx_NEMAggregateModification_NEMCosignatoryModification) Descriptor() ([]byte, []int) {
	return file_messages_nem_proto_rawDescGZIP(), []int{2, 5, 0}
}

func (x *NEMSignTx_NEMAggregateModification_NEMCosignatoryModification) GetType() NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType {
	if x != nil && x.Type != nil {
		return *x.Type
	}
	return NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_CosignatoryModification_Add
}

func (x *NEMSignTx_NEMAggregateModification_NEMCosignatoryModification) GetPublicKey() []byte {
	if x != nil {
		return x.PublicKey
	}
	return nil
}

var File_messages_nem_proto protoreflect.FileDescriptor

var file_messages_nem_proto_rawDesc = []byte{
	0x0a, 0x12, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2d, 0x6e, 0x65, 0x6d, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x12, 0x16, 0x68, 0x77, 0x2e, 0x74, 0x72, 0x65, 0x7a, 0x6f, 0x72, 0x2e,
	0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x6e, 0x65, 0x6d, 0x22, 0x6e, 0x0a, 0x0d,
	0x4e, 0x45, 0x4d, 0x47, 0x65, 0x74, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x1b, 0x0a,
	0x09, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x5f, 0x6e, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0d,
	0x52, 0x08, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x4e, 0x12, 0x1d, 0x0a, 0x07, 0x6e, 0x65,
	0x74, 0x77, 0x6f, 0x72, 0x6b, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x3a, 0x03, 0x31, 0x30, 0x34,
	0x52, 0x07, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x12, 0x21, 0x0a, 0x0c, 0x73, 0x68, 0x6f,
	0x77, 0x5f, 0x64, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x0b, 0x73, 0x68, 0x6f, 0x77, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x22, 0x26, 0x0a, 0x0a,
	0x4e, 0x45, 0x4d, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x61, 0x64,
	0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x52, 0x07, 0x61, 0x64, 0x64,
	0x72, 0x65, 0x73, 0x73, 0x22, 0x86, 0x19, 0x0a, 0x09, 0x4e, 0x45, 0x4d, 0x53, 0x69, 0x67, 0x6e,
	0x54, 0x78, 0x12, 0x58, 0x0a, 0x0b, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f,
	0x6e, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x36, 0x2e, 0x68, 0x77, 0x2e, 0x74, 0x72, 0x65,
	0x7a, 0x6f, 0x72, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x6e, 0x65, 0x6d,
	0x2e, 0x4e, 0x45, 0x4d, 0x53, 0x69, 0x67, 0x6e, 0x54, 0x78, 0x2e, 0x4e, 0x45, 0x4d, 0x54, 0x72,
	0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x52,
	0x0b, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x52, 0x0a, 0x08,
	0x6d, 0x75, 0x6c, 0x74, 0x69, 0x73, 0x69, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x36,
	0x2e, 0x68, 0x77, 0x2e, 0x74, 0x72, 0x65, 0x7a, 0x6f, 0x72, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61,
	0x67, 0x65, 0x73, 0x2e, 0x6e, 0x65, 0x6d, 0x2e, 0x4e, 0x45, 0x4d, 0x53, 0x69, 0x67, 0x6e, 0x54,
	0x78, 0x2e, 0x4e, 0x45, 0x4d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e,
	0x43, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x52, 0x08, 0x6d, 0x75, 0x6c, 0x74, 0x69, 0x73, 0x69, 0x67,
	0x12, 0x49, 0x0a, 0x08, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x68, 0x77, 0x2e, 0x74, 0x72, 0x65, 0x7a, 0x6f, 0x72, 0x2e, 0x6d,
	0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x6e, 0x65, 0x6d, 0x2e, 0x4e, 0x45, 0x4d, 0x53,
	0x69, 0x67, 0x6e, 0x54, 0x78, 0x2e, 0x4e, 0x45, 0x4d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65,
	0x72, 0x52, 0x08, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x12, 0x1c, 0x0a, 0x09, 0x63,
	0x6f, 0x73, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09,
	0x63, 0x6f, 0x73, 0x69, 0x67, 0x6e, 0x69, 0x6e, 0x67, 0x12, 0x68, 0x0a, 0x13, 0x70, 0x72, 0x6f,
	0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65,
	0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x37, 0x2e, 0x68, 0x77, 0x2e, 0x74, 0x72, 0x65, 0x7a,
	0x6f, 0x72, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x6e, 0x65, 0x6d, 0x2e,
	0x4e, 0x45, 0x4d, 0x53, 0x69, 0x67, 0x6e, 0x54, 0x78, 0x2e, 0x4e, 0x45, 0x4d, 0x50, 0x72, 0x6f,
	0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x52,
	0x12, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x70,
	0x61, 0x63, 0x65, 0x12, 0x5c, 0x0a, 0x0f, 0x6d, 0x6f, 0x73, 0x61, 0x69, 0x63, 0x5f, 0x63, 0x72,
	0x65, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x33, 0x2e, 0x68,
	0x77, 0x2e, 0x74, 0x72, 0x65, 0x7a, 0x6f, 0x72, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
	0x73, 0x2e, 0x6e, 0x65, 0x6d, 0x2e, 0x4e, 0x45, 0x4d, 0x53, 0x69, 0x67, 0x6e, 0x54, 0x78, 0x2e,
	0x4e, 0x45, 0x4d, 0x4d, 0x6f, 0x73, 0x61, 0x69, 0x63, 0x43, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x52, 0x0e, 0x6d, 0x6f, 0x73, 0x61, 0x69, 0x63, 0x43, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x12, 0x5c, 0x0a, 0x0d, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x5f, 0x63, 0x68, 0x61, 0x6e,
	0x67, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x37, 0x2e, 0x68, 0x77, 0x2e, 0x74, 0x72,
	0x65, 0x7a, 0x6f, 0x72, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x6e, 0x65,
	0x6d, 0x2e, 0x4e, 0x45, 0x4d, 0x53, 0x69, 0x67, 0x6e, 0x54, 0x78, 0x2e, 0x4e, 0x45, 0x4d, 0x4d,
	0x6f, 0x73, 0x61, 0x69, 0x63, 0x53, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x43, 0x68, 0x61, 0x6e, 0x67,
	0x65, 0x52, 0x0c, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x12,
	0x71, 0x0a, 0x16, 0x61, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x65, 0x5f, 0x6d, 0x6f, 0x64,
	0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x3a, 0x2e, 0x68, 0x77, 0x2e, 0x74, 0x72, 0x65, 0x7a, 0x6f, 0x72, 0x2e, 0x6d, 0x65, 0x73, 0x73,
	0x61, 0x67, 0x65, 0x73, 0x2e, 0x6e, 0x65, 0x6d, 0x2e, 0x4e, 0x45, 0x4d, 0x53, 0x69, 0x67, 0x6e,
	0x54, 0x78, 0x2e, 0x4e, 0x45, 0x4d, 0x41, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x65, 0x4d,
	0x6f, 0x64, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x15, 0x61, 0x67, 0x67,
	0x72, 0x65, 0x67, 0x61, 0x74, 0x65, 0x4d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x12, 0x68, 0x0a, 0x13, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x61, 0x6e, 0x63, 0x65,
	0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x37, 0x2e, 0x68, 0x77, 0x2e, 0x74, 0x72, 0x65, 0x7a, 0x6f, 0x72, 0x2e, 0x6d, 0x65, 0x73, 0x73,
	0x61, 0x67, 0x65, 0x73, 0x2e, 0x6e, 0x65, 0x6d, 0x2e, 0x4e, 0x45, 0x4d, 0x53, 0x69, 0x67, 0x6e,
	0x54, 0x78, 0x2e, 0x4e, 0x45, 0x4d, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x61, 0x6e, 0x63, 0x65,
	0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x52, 0x12, 0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74,
	0x61, 0x6e, 0x63, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x1a, 0xb6, 0x01, 0x0a,
	0x14, 0x4e, 0x45, 0x4d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x43,
	0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x12, 0x1b, 0x0a, 0x09, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x5f, 0x6e, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0d, 0x52, 0x08, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73,
	0x73, 0x4e, 0x12, 0x1d, 0x0a, 0x07, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x0d, 0x3a, 0x03, 0x31, 0x30, 0x34, 0x52, 0x07, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72,
	0x6b, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x03,
	0x20, 0x02, 0x28, 0x0d, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12,
	0x10, 0x0a, 0x03, 0x66, 0x65, 0x65, 0x18, 0x04, 0x20, 0x02, 0x28, 0x04, 0x52, 0x03, 0x66, 0x65,
	0x65, 0x12, 0x1a, 0x0a, 0x08, 0x64, 0x65, 0x61, 0x64, 0x6c, 0x69, 0x6e, 0x65, 0x18, 0x05, 0x20,
	0x02, 0x28, 0x0d, 0x52, 0x08, 0x64, 0x65, 0x61, 0x64, 0x6c, 0x69, 0x6e, 0x65, 0x12, 0x16, 0x0a,
	0x06, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x72, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x06, 0x73,
	0x69, 0x67, 0x6e, 0x65, 0x72, 0x1a, 0xae, 0x02, 0x0a, 0x0b, 0x4e, 0x45, 0x4d, 0x54, 0x72, 0x61,
	0x6e, 0x73, 0x66, 0x65, 0x72, 0x12, 0x1c, 0x0a, 0x09, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69, 0x65,
	0x6e, 0x74, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x52, 0x09, 0x72, 0x65, 0x63, 0x69, 0x70, 0x69,
	0x65, 0x6e, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20,
	0x02, 0x28, 0x04, 0x52, 0x06, 0x61, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x70,
	0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x07, 0x70, 0x61,
	0x79, 0x6c, 0x6f, 0x61, 0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x5f,
	0x6b, 0x65, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x09, 0x70, 0x75, 0x62, 0x6c, 0x69,
	0x63, 0x4b, 0x65, 0x79, 0x12, 0x51, 0x0a, 0x07, 0x6d, 0x6f, 0x73, 0x61, 0x69, 0x63, 0x73, 0x18,
	0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x37, 0x2e, 0x68, 0x77, 0x2e, 0x74, 0x72, 0x65, 0x7a, 0x6f,
	0x72, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x6e, 0x65, 0x6d, 0x2e, 0x4e,
	0x45, 0x4d, 0x53, 0x69, 0x67, 0x6e, 0x54, 0x78, 0x2e, 0x4e, 0x45, 0x4d, 0x54, 0x72, 0x61, 0x6e,
	0x73, 0x66, 0x65, 0x72, 0x2e, 0x4e, 0x45, 0x4d, 0x4d, 0x6f, 0x73, 0x61, 0x69, 0x63, 0x52, 0x07,
	0x6d, 0x6f, 0x73, 0x61, 0x69, 0x63, 0x73, 0x1a, 0x5d, 0x0a, 0x09, 0x4e, 0x45, 0x4d, 0x4d, 0x6f,
	0x73, 0x61, 0x69, 0x63, 0x12, 0x1c, 0x0a, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63,
	0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x52, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61,
	0x63, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x6d, 0x6f, 0x73, 0x61, 0x69, 0x63, 0x18, 0x02, 0x20, 0x02,
	0x28, 0x09, 0x52, 0x06, 0x6d, 0x6f, 0x73, 0x61, 0x69, 0x63, 0x12, 0x1a, 0x0a, 0x08, 0x71, 0x75,
	0x61, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x18, 0x03, 0x20, 0x02, 0x28, 0x04, 0x52, 0x08, 0x71, 0x75,
	0x61, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x1a, 0x73, 0x0a, 0x15, 0x4e, 0x45, 0x4d, 0x50, 0x72, 0x6f,
	0x76, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x12,
	0x1c, 0x0a, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x18, 0x01, 0x20, 0x02,
	0x28, 0x09, 0x52, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x12, 0x16, 0x0a,
	0x06, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x70,
	0x61, 0x72, 0x65, 0x6e, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x69, 0x6e, 0x6b, 0x18, 0x03, 0x20,
	0x02, 0x28, 0x09, 0x52, 0x04, 0x73, 0x69, 0x6e, 0x6b, 0x12, 0x10, 0x0a, 0x03, 0x66, 0x65, 0x65,
	0x18, 0x04, 0x20, 0x02, 0x28, 0x04, 0x52, 0x03, 0x66, 0x65, 0x65, 0x1a, 0x8e, 0x06, 0x0a, 0x11,
	0x4e, 0x45, 0x4d, 0x4d, 0x6f, 0x73, 0x61, 0x69, 0x63, 0x43, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x12, 0x67, 0x0a, 0x0a, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x18,
	0x01, 0x20, 0x02, 0x28, 0x0b, 0x32, 0x47, 0x2e, 0x68, 0x77, 0x2e, 0x74, 0x72, 0x65, 0x7a, 0x6f,
	0x72, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x6e, 0x65, 0x6d, 0x2e, 0x4e,
	0x45, 0x4d, 0x53, 0x69, 0x67, 0x6e, 0x54, 0x78, 0x2e, 0x4e, 0x45, 0x4d, 0x4d, 0x6f, 0x73, 0x61,
	0x69, 0x63, 0x43, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x4e, 0x45, 0x4d, 0x4d, 0x6f,
	0x73, 0x61, 0x69, 0x63, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0a,
	0x64, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a, 0x04, 0x73, 0x69,
	0x6e, 0x6b, 0x18, 0x02, 0x20, 0x02, 0x28, 0x09, 0x52, 0x04, 0x73, 0x69, 0x6e, 0x6b, 0x12, 0x10,
	0x0a, 0x03, 0x66, 0x65, 0x65, 0x18, 0x03, 0x20, 0x02, 0x28, 0x04, 0x52, 0x03, 0x66, 0x65, 0x65,
	0x1a, 0xe9, 0x04, 0x0a, 0x13, 0x4e, 0x45, 0x4d, 0x4d, 0x6f, 0x73, 0x61, 0x69, 0x63, 0x44, 0x65,
	0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x16, 0x0a, 0x06,
	0x74, 0x69, 0x63, 0x6b, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x74, 0x69,
	0x63, 0x6b, 0x65, 0x72, 0x12, 0x1c, 0x0a, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63,
	0x65, 0x18, 0x03, 0x20, 0x02, 0x28, 0x09, 0x52, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61,
	0x63, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x6d, 0x6f, 0x73, 0x61, 0x69, 0x63, 0x18, 0x04, 0x20, 0x02,
	0x28, 0x09, 0x52, 0x06, 0x6d, 0x6f, 0x73, 0x61, 0x69, 0x63, 0x12, 0x22, 0x0a, 0x0c, 0x64, 0x69,
	0x76, 0x69, 0x73, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d,
	0x52, 0x0c, 0x64, 0x69, 0x76, 0x69, 0x73, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x12, 0x69,
	0x0a, 0x04, 0x6c, 0x65, 0x76, 0x79, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x55, 0x2e, 0x68,
	0x77, 0x2e, 0x74, 0x72, 0x65, 0x7a, 0x6f, 0x72, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
	0x73, 0x2e, 0x6e, 0x65, 0x6d, 0x2e, 0x4e, 0x45, 0x4d, 0x53, 0x69, 0x67, 0x6e, 0x54, 0x78, 0x2e,
	0x4e, 0x45, 0x4d, 0x4d, 0x6f, 0x73, 0x61, 0x69, 0x63, 0x43, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x2e, 0x4e, 0x45, 0x4d, 0x4d, 0x6f, 0x73, 0x61, 0x69, 0x63, 0x44, 0x65, 0x66, 0x69, 0x6e,
	0x69, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x4e, 0x45, 0x4d, 0x4d, 0x6f, 0x73, 0x61, 0x69, 0x63, 0x4c,
	0x65, 0x76, 0x79, 0x52, 0x04, 0x6c, 0x65, 0x76, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x66, 0x65, 0x65,
	0x18, 0x07, 0x20, 0x01, 0x28, 0x04, 0x52, 0x03, 0x66, 0x65, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x6c,
	0x65, 0x76, 0x79, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x0b, 0x6c, 0x65, 0x76, 0x79, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x12, 0x25,
	0x0a, 0x0e, 0x6c, 0x65, 0x76, 0x79, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65,
	0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x6c, 0x65, 0x76, 0x79, 0x4e, 0x61, 0x6d, 0x65,
	0x73, 0x70, 0x61, 0x63, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x6c, 0x65, 0x76, 0x79, 0x5f, 0x6d, 0x6f,
	0x73, 0x61, 0x69, 0x63, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x6c, 0x65, 0x76, 0x79,
	0x4d, 0x6f, 0x73, 0x61, 0x69, 0x63, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x79,
	0x18, 0x0b, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x12, 0x25,
	0x0a, 0x0e, 0x6d, 0x75, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x79,
	0x18, 0x0c, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x6d, 0x75, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x53,
	0x75, 0x70, 0x70, 0x6c, 0x79, 0x12, 0x22, 0x0a, 0x0c, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65,
	0x72, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0c, 0x74, 0x72, 0x61,
	0x6e, 0x73, 0x66, 0x65, 0x72, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73,
	0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x0e, 0x20, 0x02, 0x28, 0x09, 0x52, 0x0b,
	0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1a, 0x0a, 0x08, 0x6e,
	0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x18, 0x0f, 0x20, 0x03, 0x28, 0x0d, 0x52, 0x08, 0x6e,
	0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x73, 0x22, 0x43, 0x0a, 0x0d, 0x4e, 0x45, 0x4d, 0x4d, 0x6f,
	0x73, 0x61, 0x69, 0x63, 0x4c, 0x65, 0x76, 0x79, 0x12, 0x17, 0x0a, 0x13, 0x4d, 0x6f, 0x73, 0x61,
	0x69, 0x63, 0x4c, 0x65, 0x76, 0x79, 0x5f, 0x41, 0x62, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x65, 0x10,
	0x01, 0x12, 0x19, 0x0a, 0x15, 0x4d, 0x6f, 0x73, 0x61, 0x69, 0x63, 0x4c, 0x65, 0x76, 0x79, 0x5f,
	0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74, 0x69, 0x6c, 0x65, 0x10, 0x02, 0x1a, 0x91, 0x02, 0x0a,
	0x15, 0x4e, 0x45, 0x4d, 0x4d, 0x6f, 0x73, 0x61, 0x69, 0x63, 0x53, 0x75, 0x70, 0x70, 0x6c, 0x79,
	0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70,
	0x61, 0x63, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x09, 0x52, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x73,
	0x70, 0x61, 0x63, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x6d, 0x6f, 0x73, 0x61, 0x69, 0x63, 0x18, 0x02,
	0x20, 0x02, 0x28, 0x09, 0x52, 0x06, 0x6d, 0x6f, 0x73, 0x61, 0x69, 0x63, 0x12, 0x5f, 0x0a, 0x04,
	0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x02, 0x28, 0x0e, 0x32, 0x4b, 0x2e, 0x68, 0x77, 0x2e,
	0x74, 0x72, 0x65, 0x7a, 0x6f, 0x72, 0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e,
	0x6e, 0x65, 0x6d, 0x2e, 0x4e, 0x45, 0x4d, 0x53, 0x69, 0x67, 0x6e, 0x54, 0x78, 0x2e, 0x4e, 0x45,
	0x4d, 0x4d, 0x6f, 0x73, 0x61, 0x69, 0x63, 0x53, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x43, 0x68, 0x61,
	0x6e, 0x67, 0x65, 0x2e, 0x4e, 0x45, 0x4d, 0x53, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x43, 0x68, 0x61,
	0x6e, 0x67, 0x65, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x14, 0x0a,
	0x05, 0x64, 0x65, 0x6c, 0x74, 0x61, 0x18, 0x04, 0x20, 0x02, 0x28, 0x04, 0x52, 0x05, 0x64, 0x65,
	0x6c, 0x74, 0x61, 0x22, 0x4b, 0x0a, 0x13, 0x4e, 0x45, 0x4d, 0x53, 0x75, 0x70, 0x70, 0x6c, 0x79,
	0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x54, 0x79, 0x70, 0x65, 0x12, 0x19, 0x0a, 0x15, 0x53, 0x75,
	0x70, 0x70, 0x6c, 0x79, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x5f, 0x49, 0x6e, 0x63, 0x72, 0x65,
	0x61, 0x73, 0x65, 0x10, 0x01, 0x12, 0x19, 0x0a, 0x15, 0x53, 0x75, 0x70, 0x70, 0x6c, 0x79, 0x43,
	0x68, 0x61, 0x6e, 0x67, 0x65, 0x5f, 0x44, 0x65, 0x63, 0x72, 0x65, 0x61, 0x73, 0x65, 0x10, 0x02,
	0x1a, 0xd9, 0x03, 0x0a, 0x18, 0x4e, 0x45, 0x4d, 0x41, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74,
	0x65, 0x4d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x7b, 0x0a,
	0x0d, 0x6d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x01,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x55, 0x2e, 0x68, 0x77, 0x2e, 0x74, 0x72, 0x65, 0x7a, 0x6f, 0x72,
	0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x6e, 0x65, 0x6d, 0x2e, 0x4e, 0x45,
	0x4d, 0x53, 0x69, 0x67, 0x6e, 0x54, 0x78, 0x2e, 0x4e, 0x45, 0x4d, 0x41, 0x67, 0x67, 0x72, 0x65,
	0x67, 0x61, 0x74, 0x65, 0x4d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x2e, 0x4e, 0x45, 0x4d, 0x43, 0x6f, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x6f, 0x72, 0x79, 0x4d,
	0x6f, 0x64, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0d, 0x6d, 0x6f, 0x64,
	0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x27, 0x0a, 0x0f, 0x72, 0x65,
	0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x11, 0x52, 0x0e, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x43, 0x68, 0x61,
	0x6e, 0x67, 0x65, 0x1a, 0x96, 0x02, 0x0a, 0x1a, 0x4e, 0x45, 0x4d, 0x43, 0x6f, 0x73, 0x69, 0x67,
	0x6e, 0x61, 0x74, 0x6f, 0x72, 0x79, 0x4d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x12, 0x7d, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0e,
	0x32, 0x69, 0x2e, 0x68, 0x77, 0x2e, 0x74, 0x72, 0x65, 0x7a, 0x6f, 0x72, 0x2e, 0x6d, 0x65, 0x73,
	0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x6e, 0x65, 0x6d, 0x2e, 0x4e, 0x45, 0x4d, 0x53, 0x69, 0x67,
	0x6e, 0x54, 0x78, 0x2e, 0x4e, 0x45, 0x4d, 0x41, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x65,
	0x4d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x4e, 0x45, 0x4d,
	0x43, 0x6f, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x6f, 0x72, 0x79, 0x4d, 0x6f, 0x64, 0x69, 0x66,
	0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x4e, 0x45, 0x4d, 0x4d, 0x6f, 0x64, 0x69, 0x66,
	0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70,
	0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x5f, 0x6b, 0x65, 0x79, 0x18,
	0x02, 0x20, 0x02, 0x28, 0x0c, 0x52, 0x09, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x4b, 0x65, 0x79,
	0x22, 0x5a, 0x0a, 0x13, 0x4e, 0x45, 0x4d, 0x4d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1f, 0x0a, 0x1b, 0x43, 0x6f, 0x73, 0x69, 0x67,
	0x6e, 0x61, 0x74, 0x6f, 0x72, 0x79, 0x4d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x5f, 0x41, 0x64, 0x64, 0x10, 0x01, 0x12, 0x22, 0x0a, 0x1e, 0x43, 0x6f, 0x73, 0x69,
	0x67, 0x6e, 0x61, 0x74, 0x6f, 0x72, 0x79, 0x4d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x5f, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x10, 0x02, 0x1a, 0xfe, 0x01, 0x0a,
	0x15, 0x4e, 0x45, 0x4d, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x54, 0x72,
	0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x12, 0x65, 0x0a, 0x04, 0x6d, 0x6f, 0x64, 0x65, 0x18, 0x01,
	0x20, 0x02, 0x28, 0x0e, 0x32, 0x51, 0x2e, 0x68, 0x77, 0x2e, 0x74, 0x72, 0x65, 0x7a, 0x6f, 0x72,
	0x2e, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x2e, 0x6e, 0x65, 0x6d, 0x2e, 0x4e, 0x45,
	0x4d, 0x53, 0x69, 0x67, 0x6e, 0x54, 0x78, 0x2e, 0x4e, 0x45, 0x4d, 0x49, 0x6d, 0x70, 0x6f, 0x72,
	0x74, 0x61, 0x6e, 0x63, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x2e, 0x4e, 0x45,
	0x4d, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73,
	0x66, 0x65, 0x72, 0x4d, 0x6f, 0x64, 0x65, 0x52, 0x04, 0x6d, 0x6f, 0x64, 0x65, 0x12, 0x1d, 0x0a,
	0x0a, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x02, 0x28,
	0x0c, 0x52, 0x09, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x4b, 0x65, 0x79, 0x22, 0x5f, 0x0a, 0x19,
	0x4e, 0x45, 0x4d, 0x49, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x54, 0x72, 0x61,
	0x6e, 0x73, 0x66, 0x65, 0x72, 0x4d, 0x6f, 0x64, 0x65, 0x12, 0x1f, 0x0a, 0x1b, 0x49, 0x6d, 0x70,
	0x6f, 0x72, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x5f,
	0x41, 0x63, 0x74, 0x69, 0x76, 0x61, 0x74, 0x65, 0x10, 0x01, 0x12, 0x21, 0x0a, 0x1d, 0x49, 0x6d,
	0x70, 0x6f, 0x72, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72,
	0x5f, 0x44, 0x65, 0x61, 0x63, 0x74, 0x69, 0x76, 0x61, 0x74, 0x65, 0x10, 0x02, 0x22, 0x3f, 0x0a,
	0x0b, 0x4e, 0x45, 0x4d, 0x53, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x54, 0x78, 0x12, 0x12, 0x0a, 0x04,
	0x64, 0x61, 0x74, 0x61, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0c, 0x52, 0x04, 0x64, 0x61, 0x74, 0x61,
	0x12, 0x1c, 0x0a, 0x09, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x18, 0x02, 0x20,
	0x02, 0x28, 0x0c, 0x52, 0x09, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x22, 0x83,
	0x01, 0x0a, 0x11, 0x4e, 0x45, 0x4d, 0x44, 0x65, 0x63, 0x72, 0x79, 0x70, 0x74, 0x4d, 0x65, 0x73,
	0x73, 0x61, 0x67, 0x65, 0x12, 0x1b, 0x0a, 0x09, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x5f,
	0x6e, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0d, 0x52, 0x08, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
	0x4e, 0x12, 0x18, 0x0a, 0x07, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0d, 0x52, 0x07, 0x6e, 0x65, 0x74, 0x77, 0x6f, 0x72, 0x6b, 0x12, 0x1d, 0x0a, 0x0a, 0x70,
	0x75, 0x62, 0x6c, 0x69, 0x63, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52,
	0x09, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x4b, 0x65, 0x79, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x61,
	0x79, 0x6c, 0x6f, 0x61, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x07, 0x70, 0x61, 0x79,
	0x6c, 0x6f, 0x61, 0x64, 0x22, 0x2f, 0x0a, 0x13, 0x4e, 0x45, 0x4d, 0x44, 0x65, 0x63, 0x72, 0x79,
	0x70, 0x74, 0x65, 0x64, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x70,
	0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x18, 0x01, 0x20, 0x02, 0x28, 0x0c, 0x52, 0x07, 0x70, 0x61,
	0x79, 0x6c, 0x6f, 0x61, 0x64, 0x42, 0x37, 0x0a, 0x23, 0x63, 0x6f, 0x6d, 0x2e, 0x73, 0x61, 0x74,
	0x6f, 0x73, 0x68, 0x69, 0x6c, 0x61, 0x62, 0x73, 0x2e, 0x74, 0x72, 0x65, 0x7a, 0x6f, 0x72, 0x2e,
	0x6c, 0x69, 0x62, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x42, 0x10, 0x54, 0x72,
	0x65, 0x7a, 0x6f, 0x72, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x4e, 0x65, 0x6d,
}

var (
	file_messages_nem_proto_rawDescOnce sync.Once
	file_messages_nem_proto_rawDescData = file_messages_nem_proto_rawDesc
)

func file_messages_nem_proto_rawDescGZIP() []byte {
	file_messages_nem_proto_rawDescOnce.Do(func() {
		file_messages_nem_proto_rawDescData = protoimpl.X.CompressGZIP(file_messages_nem_proto_rawDescData)
	})
	return file_messages_nem_proto_rawDescData
}

var file_messages_nem_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_messages_nem_proto_msgTypes = make([]protoimpl.MessageInfo, 16)
var file_messages_nem_proto_goTypes = []interface{}{
	(NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition_NEMMosaicLevy)(0),                     // 0: hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.NEMMosaicLevy
	(NEMSignTx_NEMMosaicSupplyChange_NEMSupplyChangeType)(0),                               // 1: hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.NEMSupplyChangeType
	(NEMSignTx_NEMAggregateModification_NEMCosignatoryModification_NEMModificationType)(0), // 2: hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification.NEMModificationType
	(NEMSignTx_NEMImportanceTransfer_NEMImportanceTransferMode)(0),                         // 3: hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer.NEMImportanceTransferMode
	(*NEMGetAddress)(nil),                                                 // 4: hw.trezor.messages.nem.NEMGetAddress
	(*NEMAddress)(nil),                                                    // 5: hw.trezor.messages.nem.NEMAddress
	(*NEMSignTx)(nil),                                                     // 6: hw.trezor.messages.nem.NEMSignTx
	(*NEMSignedTx)(nil),                                                   // 7: hw.trezor.messages.nem.NEMSignedTx
	(*NEMDecryptMessage)(nil),                                             // 8: hw.trezor.messages.nem.NEMDecryptMessage
	(*NEMDecryptedMessage)(nil),                                           // 9: hw.trezor.messages.nem.NEMDecryptedMessage
	(*NEMSignTx_NEMTransactionCommon)(nil),                                // 10: hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon
	(*NEMSignTx_NEMTransfer)(nil),                                         // 11: hw.trezor.messages.nem.NEMSignTx.NEMTransfer
	(*NEMSignTx_NEMProvisionNamespace)(nil),                               // 12: hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace
	(*NEMSignTx_NEMMosaicCreation)(nil),                                   // 13: hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation
	(*NEMSignTx_NEMMosaicSupplyChange)(nil),                               // 14: hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange
	(*NEMSignTx_NEMAggregateModification)(nil),                            // 15: hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification
	(*NEMSignTx_NEMImportanceTransfer)(nil),                               // 16: hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer
	(*NEMSignTx_NEMTransfer_NEMMosaic)(nil),                               // 17: hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic
	(*NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition)(nil),               // 18: hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition
	(*NEMSignTx_NEMAggregateModification_NEMCosignatoryModification)(nil), // 19: hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification
}
var file_messages_nem_proto_depIdxs = []int32{
	10, // 0: hw.trezor.messages.nem.NEMSignTx.transaction:type_name -> hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon
	10, // 1: hw.trezor.messages.nem.NEMSignTx.multisig:type_name -> hw.trezor.messages.nem.NEMSignTx.NEMTransactionCommon
	11, // 2: hw.trezor.messages.nem.NEMSignTx.transfer:type_name -> hw.trezor.messages.nem.NEMSignTx.NEMTransfer
	12, // 3: hw.trezor.messages.nem.NEMSignTx.provision_namespace:type_name -> hw.trezor.messages.nem.NEMSignTx.NEMProvisionNamespace
	13, // 4: hw.trezor.messages.nem.NEMSignTx.mosaic_creation:type_name -> hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation
	14, // 5: hw.trezor.messages.nem.NEMSignTx.supply_change:type_name -> hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange
	15, // 6: hw.trezor.messages.nem.NEMSignTx.aggregate_modification:type_name -> hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification
	16, // 7: hw.trezor.messages.nem.NEMSignTx.importance_transfer:type_name -> hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer
	17, // 8: hw.trezor.messages.nem.NEMSignTx.NEMTransfer.mosaics:type_name -> hw.trezor.messages.nem.NEMSignTx.NEMTransfer.NEMMosaic
	18, // 9: hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.definition:type_name -> hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition
	1,  // 10: hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.type:type_name -> hw.trezor.messages.nem.NEMSignTx.NEMMosaicSupplyChange.NEMSupplyChangeType
	19, // 11: hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.modifications:type_name -> hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification
	3,  // 12: hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer.mode:type_name -> hw.trezor.messages.nem.NEMSignTx.NEMImportanceTransfer.NEMImportanceTransferMode
	0,  // 13: hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.levy:type_name -> hw.trezor.messages.nem.NEMSignTx.NEMMosaicCreation.NEMMosaicDefinition.NEMMosaicLevy
	2,  // 14: hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification.type:type_name -> hw.trezor.messages.nem.NEMSignTx.NEMAggregateModification.NEMCosignatoryModification.NEMModificationType
	15, // [15:15] is the sub-list for method output_type
	15, // [15:15] is the sub-list for method input_type
	15, // [15:15] is the sub-list for extension type_name
	15, // [15:15] is the sub-list for extension extendee
	0,  // [0:15] is the sub-list for field type_name
}

func init() { file_messages_nem_proto_init() }
func file_messages_nem_proto_init() {
	if File_messages_nem_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_messages_nem_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NEMGetAddress); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_messages_nem_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NEMAddress); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_messages_nem_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NEMSignTx); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_messages_nem_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NEMSignedTx); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_messages_nem_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NEMDecryptMessage); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_messages_nem_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NEMDecryptedMessage); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_messages_nem_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NEMSignTx_NEMTransactionCommon); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_messages_nem_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NEMSignTx_NEMTransfer); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_messages_nem_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NEMSignTx_NEMProvisionNamespace); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_messages_nem_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NEMSignTx_NEMMosaicCreation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_messages_nem_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NEMSignTx_NEMMosaicSupplyChange); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_messages_nem_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NEMSignTx_NEMAggregateModification); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_messages_nem_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NEMSignTx_NEMImportanceTransfer); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_messages_nem_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NEMSignTx_NEMTransfer_NEMMosaic); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_messages_nem_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NEMSignTx_NEMMosaicCreation_NEMMosaicDefinition); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_messages_nem_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NEMSignTx_NEMAggregateModification_NEMCosignatoryModification); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_messages_nem_proto_rawDesc,
			NumEnums:      4,
			NumMessages:   16,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_messages_nem_proto_goTypes,
		DependencyIndexes: file_messages_nem_proto_depIdxs,
		EnumInfos:         file_messages_nem_proto_enumTypes,
		MessageInfos:      file_messages_nem_proto_msgTypes,
	}.Build()
	File_messages_nem_proto = out.File
	file_messages_nem_proto_rawDesc = nil
	file_messages_nem_proto_goTypes = nil
	file_messages_nem_proto_depIdxs = nil
}
